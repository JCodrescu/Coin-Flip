{"ast":null,"code":"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict';\n\nvar isWindows = process.platform === 'win32';\n\nvar util = require('util'); // resolves . and .. elements in a path array with directory names there\n// must be no slashes or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\n\n\nfunction normalizeArray(parts, allowAboveRoot) {\n  var res = [];\n\n  for (var i = 0; i < parts.length; i++) {\n    var p = parts[i]; // ignore empty parts\n\n    if (!p || p === '.') continue;\n\n    if (p === '..') {\n      if (res.length && res[res.length - 1] !== '..') {\n        res.pop();\n      } else if (allowAboveRoot) {\n        res.push('..');\n      }\n    } else {\n      res.push(p);\n    }\n  }\n\n  return res;\n} // returns an array with empty elements removed from either end of the input\n// array or the original array if no elements need to be removed\n\n\nfunction trimArray(arr) {\n  var lastIndex = arr.length - 1;\n  var start = 0;\n\n  for (; start <= lastIndex; start++) {\n    if (arr[start]) break;\n  }\n\n  var end = lastIndex;\n\n  for (; end >= 0; end--) {\n    if (arr[end]) break;\n  }\n\n  if (start === 0 && end === lastIndex) return arr;\n  if (start > end) return [];\n  return arr.slice(start, end + 1);\n} // Regex to split a windows path into three parts: [*, device, slash,\n// tail] windows-only\n\n\nvar splitDeviceRe = /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/; // Regex to split the tail part of the above into [*, dir, basename, ext]\n\nvar splitTailRe = /^([\\s\\S]*?)((?:\\.{1,2}|[^\\\\\\/]+?|)(\\.[^.\\/\\\\]*|))(?:[\\\\\\/]*)$/;\nvar win32 = {}; // Function to split a filename into [root, dir, basename, ext]\n\nfunction win32SplitPath(filename) {\n  // Separate device+slash from tail\n  var result = splitDeviceRe.exec(filename),\n      device = (result[1] || '') + (result[2] || ''),\n      tail = result[3] || ''; // Split the tail into dir, basename and extension\n\n  var result2 = splitTailRe.exec(tail),\n      dir = result2[1],\n      basename = result2[2],\n      ext = result2[3];\n  return [device, dir, basename, ext];\n}\n\nfunction win32StatPath(path) {\n  var result = splitDeviceRe.exec(path),\n      device = result[1] || '',\n      isUnc = !!device && device[1] !== ':';\n  return {\n    device: device,\n    isUnc: isUnc,\n    isAbsolute: isUnc || !!result[2],\n    // UNC paths are always absolute\n    tail: result[3]\n  };\n}\n\nfunction normalizeUNCRoot(device) {\n  return '\\\\\\\\' + device.replace(/^[\\\\\\/]+/, '').replace(/[\\\\\\/]+/g, '\\\\');\n} // path.resolve([from ...], to)\n\n\nwin32.resolve = function () {\n  var resolvedDevice = '',\n      resolvedTail = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1; i--) {\n    var path;\n\n    if (i >= 0) {\n      path = arguments[i];\n    } else if (!resolvedDevice) {\n      path = process.cwd();\n    } else {\n      // Windows has the concept of drive-specific current working\n      // directories. If we've resolved a drive letter but not yet an\n      // absolute path, get cwd for that drive. We're sure the device is not\n      // an unc path at this points, because unc paths are always absolute.\n      path = process.env['=' + resolvedDevice]; // Verify that a drive-local cwd was found and that it actually points\n      // to our drive. If not, default to the drive's root.\n\n      if (!path || path.substr(0, 3).toLowerCase() !== resolvedDevice.toLowerCase() + '\\\\') {\n        path = resolvedDevice + '\\\\';\n      }\n    } // Skip empty and invalid entries\n\n\n    if (!util.isString(path)) {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    var result = win32StatPath(path),\n        device = result.device,\n        isUnc = result.isUnc,\n        isAbsolute = result.isAbsolute,\n        tail = result.tail;\n\n    if (device && resolvedDevice && device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n      // This path points to another device so it is not applicable\n      continue;\n    }\n\n    if (!resolvedDevice) {\n      resolvedDevice = device;\n    }\n\n    if (!resolvedAbsolute) {\n      resolvedTail = tail + '\\\\' + resolvedTail;\n      resolvedAbsolute = isAbsolute;\n    }\n\n    if (resolvedDevice && resolvedAbsolute) {\n      break;\n    }\n  } // Convert slashes to backslashes when `resolvedDevice` points to an UNC\n  // root. Also squash multiple slashes into a single one where appropriate.\n\n\n  if (isUnc) {\n    resolvedDevice = normalizeUNCRoot(resolvedDevice);\n  } // At this point the path should be resolved to a full absolute path,\n  // but handle relative paths to be safe (might happen when process.cwd()\n  // fails)\n  // Normalize the tail path\n\n\n  resolvedTail = normalizeArray(resolvedTail.split(/[\\\\\\/]+/), !resolvedAbsolute).join('\\\\');\n  return resolvedDevice + (resolvedAbsolute ? '\\\\' : '') + resolvedTail || '.';\n};\n\nwin32.normalize = function (path) {\n  var result = win32StatPath(path),\n      device = result.device,\n      isUnc = result.isUnc,\n      isAbsolute = result.isAbsolute,\n      tail = result.tail,\n      trailingSlash = /[\\\\\\/]$/.test(tail); // Normalize the tail path\n\n  tail = normalizeArray(tail.split(/[\\\\\\/]+/), !isAbsolute).join('\\\\');\n\n  if (!tail && !isAbsolute) {\n    tail = '.';\n  }\n\n  if (tail && trailingSlash) {\n    tail += '\\\\';\n  } // Convert slashes to backslashes when `device` points to an UNC root.\n  // Also squash multiple slashes into a single one where appropriate.\n\n\n  if (isUnc) {\n    device = normalizeUNCRoot(device);\n  }\n\n  return device + (isAbsolute ? '\\\\' : '') + tail;\n};\n\nwin32.isAbsolute = function (path) {\n  return win32StatPath(path).isAbsolute;\n};\n\nwin32.join = function () {\n  var paths = [];\n\n  for (var i = 0; i < arguments.length; i++) {\n    var arg = arguments[i];\n\n    if (!util.isString(arg)) {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n\n    if (arg) {\n      paths.push(arg);\n    }\n  }\n\n  var joined = paths.join('\\\\'); // Make sure that the joined path doesn't start with two slashes, because\n  // normalize() will mistake it for an UNC path then.\n  //\n  // This step is skipped when it is very clear that the user actually\n  // intended to point at an UNC path. This is assumed when the first\n  // non-empty string arguments starts with exactly two slashes followed by\n  // at least one more non-slash character.\n  //\n  // Note that for normalize() to treat a path as an UNC path it needs to\n  // have at least 2 components, so we don't filter for that here.\n  // This means that the user can use join to construct UNC paths from\n  // a server name and a share name; for example:\n  //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\')\n\n  if (!/^[\\\\\\/]{2}[^\\\\\\/]/.test(paths[0])) {\n    joined = joined.replace(/^[\\\\\\/]{2,}/, '\\\\');\n  }\n\n  return win32.normalize(joined);\n}; // path.relative(from, to)\n// it will solve the relative path from 'from' to 'to', for instance:\n// from = 'C:\\\\orandea\\\\test\\\\aaa'\n// to = 'C:\\\\orandea\\\\impl\\\\bbb'\n// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n\n\nwin32.relative = function (from, to) {\n  from = win32.resolve(from);\n  to = win32.resolve(to); // windows is not case sensitive\n\n  var lowerFrom = from.toLowerCase();\n  var lowerTo = to.toLowerCase();\n  var toParts = trimArray(to.split('\\\\'));\n  var lowerFromParts = trimArray(lowerFrom.split('\\\\'));\n  var lowerToParts = trimArray(lowerTo.split('\\\\'));\n  var length = Math.min(lowerFromParts.length, lowerToParts.length);\n  var samePartsLength = length;\n\n  for (var i = 0; i < length; i++) {\n    if (lowerFromParts[i] !== lowerToParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  if (samePartsLength == 0) {\n    return to;\n  }\n\n  var outputParts = [];\n\n  for (var i = samePartsLength; i < lowerFromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n  return outputParts.join('\\\\');\n};\n\nwin32._makeLong = function (path) {\n  // Note: this will *probably* throw somewhere.\n  if (!util.isString(path)) return path;\n\n  if (!path) {\n    return '';\n  }\n\n  var resolvedPath = win32.resolve(path);\n\n  if (/^[a-zA-Z]\\:\\\\/.test(resolvedPath)) {\n    // path is local filesystem path, which needs to be converted\n    // to long UNC path.\n    return '\\\\\\\\?\\\\' + resolvedPath;\n  } else if (/^\\\\\\\\[^?.]/.test(resolvedPath)) {\n    // path is network UNC path, which needs to be converted\n    // to long UNC path.\n    return '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.substring(2);\n  }\n\n  return path;\n};\n\nwin32.dirname = function (path) {\n  var result = win32SplitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\nwin32.basename = function (path, ext) {\n  var f = win32SplitPath(path)[2]; // TODO: make this comparison case-insensitive on windows?\n\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n\n  return f;\n};\n\nwin32.extname = function (path) {\n  return win32SplitPath(path)[3];\n};\n\nwin32.format = function (pathObject) {\n  if (!util.isObject(pathObject)) {\n    throw new TypeError(\"Parameter 'pathObject' must be an object, not \" + typeof pathObject);\n  }\n\n  var root = pathObject.root || '';\n\n  if (!util.isString(root)) {\n    throw new TypeError(\"'pathObject.root' must be a string or undefined, not \" + typeof pathObject.root);\n  }\n\n  var dir = pathObject.dir;\n  var base = pathObject.base || '';\n\n  if (!dir) {\n    return base;\n  }\n\n  if (dir[dir.length - 1] === win32.sep) {\n    return dir + base;\n  }\n\n  return dir + win32.sep + base;\n};\n\nwin32.parse = function (pathString) {\n  if (!util.isString(pathString)) {\n    throw new TypeError(\"Parameter 'pathString' must be a string, not \" + typeof pathString);\n  }\n\n  var allParts = win32SplitPath(pathString);\n\n  if (!allParts || allParts.length !== 4) {\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\n  }\n\n  return {\n    root: allParts[0],\n    dir: allParts[0] + allParts[1].slice(0, -1),\n    base: allParts[2],\n    ext: allParts[3],\n    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\n  };\n};\n\nwin32.sep = '\\\\';\nwin32.delimiter = ';'; // Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\n\nvar splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar posix = {};\n\nfunction posixSplitPath(filename) {\n  return splitPathRe.exec(filename).slice(1);\n} // path.resolve([from ...], to)\n// posix version\n\n\nposix.resolve = function () {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = i >= 0 ? arguments[i] : process.cwd(); // Skip empty and invalid entries\n\n    if (!util.isString(path)) {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path[0] === '/';\n  } // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n  // Normalize the path\n\n\n  resolvedPath = normalizeArray(resolvedPath.split('/'), !resolvedAbsolute).join('/');\n  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';\n}; // path.normalize(path)\n// posix version\n\n\nposix.normalize = function (path) {\n  var isAbsolute = posix.isAbsolute(path),\n      trailingSlash = path && path[path.length - 1] === '/'; // Normalize the path\n\n  path = normalizeArray(path.split('/'), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n}; // posix version\n\n\nposix.isAbsolute = function (path) {\n  return path.charAt(0) === '/';\n}; // posix version\n\n\nposix.join = function () {\n  var path = '';\n\n  for (var i = 0; i < arguments.length; i++) {\n    var segment = arguments[i];\n\n    if (!util.isString(segment)) {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n\n    if (segment) {\n      if (!path) {\n        path += segment;\n      } else {\n        path += '/' + segment;\n      }\n    }\n  }\n\n  return posix.normalize(path);\n}; // path.relative(from, to)\n// posix version\n\n\nposix.relative = function (from, to) {\n  from = posix.resolve(from).substr(1);\n  to = posix.resolve(to).substr(1);\n  var fromParts = trimArray(from.split('/'));\n  var toParts = trimArray(to.split('/'));\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n  return outputParts.join('/');\n};\n\nposix._makeLong = function (path) {\n  return path;\n};\n\nposix.dirname = function (path) {\n  var result = posixSplitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\nposix.basename = function (path, ext) {\n  var f = posixSplitPath(path)[2]; // TODO: make this comparison case-insensitive on windows?\n\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n\n  return f;\n};\n\nposix.extname = function (path) {\n  return posixSplitPath(path)[3];\n};\n\nposix.format = function (pathObject) {\n  if (!util.isObject(pathObject)) {\n    throw new TypeError(\"Parameter 'pathObject' must be an object, not \" + typeof pathObject);\n  }\n\n  var root = pathObject.root || '';\n\n  if (!util.isString(root)) {\n    throw new TypeError(\"'pathObject.root' must be a string or undefined, not \" + typeof pathObject.root);\n  }\n\n  var dir = pathObject.dir ? pathObject.dir + posix.sep : '';\n  var base = pathObject.base || '';\n  return dir + base;\n};\n\nposix.parse = function (pathString) {\n  if (!util.isString(pathString)) {\n    throw new TypeError(\"Parameter 'pathString' must be a string, not \" + typeof pathString);\n  }\n\n  var allParts = posixSplitPath(pathString);\n\n  if (!allParts || allParts.length !== 4) {\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\n  }\n\n  allParts[1] = allParts[1] || '';\n  allParts[2] = allParts[2] || '';\n  allParts[3] = allParts[3] || '';\n  return {\n    root: allParts[0],\n    dir: allParts[0] + allParts[1].slice(0, -1),\n    base: allParts[2],\n    ext: allParts[3],\n    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\n  };\n};\n\nposix.sep = '/';\nposix.delimiter = ':';\nif (isWindows) module.exports = win32;else\n  /* posix */\n  module.exports = posix;\nmodule.exports.posix = posix;\nmodule.exports.win32 = win32;","map":{"version":3,"sources":["/Users/joshcodrescu/Desktop/coin-flip/client/node_modules/path/path.js"],"names":["isWindows","process","platform","util","require","normalizeArray","parts","allowAboveRoot","res","i","length","p","pop","push","trimArray","arr","lastIndex","start","end","slice","splitDeviceRe","splitTailRe","win32","win32SplitPath","filename","result","exec","device","tail","result2","dir","basename","ext","win32StatPath","path","isUnc","isAbsolute","normalizeUNCRoot","replace","resolve","resolvedDevice","resolvedTail","resolvedAbsolute","arguments","cwd","env","substr","toLowerCase","isString","TypeError","split","join","normalize","trailingSlash","test","paths","arg","joined","relative","from","to","lowerFrom","lowerTo","toParts","lowerFromParts","lowerToParts","Math","min","samePartsLength","outputParts","concat","_makeLong","resolvedPath","substring","dirname","root","f","extname","format","pathObject","isObject","base","sep","parse","pathString","allParts","name","delimiter","splitPathRe","posix","posixSplitPath","charAt","segment","fromParts","module","exports"],"mappings":"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","sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n'use strict';\r\n\r\n\r\nvar isWindows = process.platform === 'win32';\r\nvar util = require('util');\r\n\r\n\r\n// resolves . and .. elements in a path array with directory names there\r\n// must be no slashes or device names (c:\\) in the array\r\n// (so also no leading and trailing slashes - it does not distinguish\r\n// relative and absolute paths)\r\nfunction normalizeArray(parts, allowAboveRoot) {\r\n  var res = [];\r\n  for (var i = 0; i < parts.length; i++) {\r\n    var p = parts[i];\r\n\r\n    // ignore empty parts\r\n    if (!p || p === '.')\r\n      continue;\r\n\r\n    if (p === '..') {\r\n      if (res.length && res[res.length - 1] !== '..') {\r\n        res.pop();\r\n      } else if (allowAboveRoot) {\r\n        res.push('..');\r\n      }\r\n    } else {\r\n      res.push(p);\r\n    }\r\n  }\r\n\r\n  return res;\r\n}\r\n\r\n// returns an array with empty elements removed from either end of the input\r\n// array or the original array if no elements need to be removed\r\nfunction trimArray(arr) {\r\n  var lastIndex = arr.length - 1;\r\n  var start = 0;\r\n  for (; start <= lastIndex; start++) {\r\n    if (arr[start])\r\n      break;\r\n  }\r\n\r\n  var end = lastIndex;\r\n  for (; end >= 0; end--) {\r\n    if (arr[end])\r\n      break;\r\n  }\r\n\r\n  if (start === 0 && end === lastIndex)\r\n    return arr;\r\n  if (start > end)\r\n    return [];\r\n  return arr.slice(start, end + 1);\r\n}\r\n\r\n// Regex to split a windows path into three parts: [*, device, slash,\r\n// tail] windows-only\r\nvar splitDeviceRe =\r\n    /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\r\n\r\n// Regex to split the tail part of the above into [*, dir, basename, ext]\r\nvar splitTailRe =\r\n    /^([\\s\\S]*?)((?:\\.{1,2}|[^\\\\\\/]+?|)(\\.[^.\\/\\\\]*|))(?:[\\\\\\/]*)$/;\r\n\r\nvar win32 = {};\r\n\r\n// Function to split a filename into [root, dir, basename, ext]\r\nfunction win32SplitPath(filename) {\r\n  // Separate device+slash from tail\r\n  var result = splitDeviceRe.exec(filename),\r\n      device = (result[1] || '') + (result[2] || ''),\r\n      tail = result[3] || '';\r\n  // Split the tail into dir, basename and extension\r\n  var result2 = splitTailRe.exec(tail),\r\n      dir = result2[1],\r\n      basename = result2[2],\r\n      ext = result2[3];\r\n  return [device, dir, basename, ext];\r\n}\r\n\r\nfunction win32StatPath(path) {\r\n  var result = splitDeviceRe.exec(path),\r\n      device = result[1] || '',\r\n      isUnc = !!device && device[1] !== ':';\r\n  return {\r\n    device: device,\r\n    isUnc: isUnc,\r\n    isAbsolute: isUnc || !!result[2], // UNC paths are always absolute\r\n    tail: result[3]\r\n  };\r\n}\r\n\r\nfunction normalizeUNCRoot(device) {\r\n  return '\\\\\\\\' + device.replace(/^[\\\\\\/]+/, '').replace(/[\\\\\\/]+/g, '\\\\');\r\n}\r\n\r\n// path.resolve([from ...], to)\r\nwin32.resolve = function() {\r\n  var resolvedDevice = '',\r\n      resolvedTail = '',\r\n      resolvedAbsolute = false;\r\n\r\n  for (var i = arguments.length - 1; i >= -1; i--) {\r\n    var path;\r\n    if (i >= 0) {\r\n      path = arguments[i];\r\n    } else if (!resolvedDevice) {\r\n      path = process.cwd();\r\n    } else {\r\n      // Windows has the concept of drive-specific current working\r\n      // directories. If we've resolved a drive letter but not yet an\r\n      // absolute path, get cwd for that drive. We're sure the device is not\r\n      // an unc path at this points, because unc paths are always absolute.\r\n      path = process.env['=' + resolvedDevice];\r\n      // Verify that a drive-local cwd was found and that it actually points\r\n      // to our drive. If not, default to the drive's root.\r\n      if (!path || path.substr(0, 3).toLowerCase() !==\r\n          resolvedDevice.toLowerCase() + '\\\\') {\r\n        path = resolvedDevice + '\\\\';\r\n      }\r\n    }\r\n\r\n    // Skip empty and invalid entries\r\n    if (!util.isString(path)) {\r\n      throw new TypeError('Arguments to path.resolve must be strings');\r\n    } else if (!path) {\r\n      continue;\r\n    }\r\n\r\n    var result = win32StatPath(path),\r\n        device = result.device,\r\n        isUnc = result.isUnc,\r\n        isAbsolute = result.isAbsolute,\r\n        tail = result.tail;\r\n\r\n    if (device &&\r\n        resolvedDevice &&\r\n        device.toLowerCase() !== resolvedDevice.toLowerCase()) {\r\n      // This path points to another device so it is not applicable\r\n      continue;\r\n    }\r\n\r\n    if (!resolvedDevice) {\r\n      resolvedDevice = device;\r\n    }\r\n    if (!resolvedAbsolute) {\r\n      resolvedTail = tail + '\\\\' + resolvedTail;\r\n      resolvedAbsolute = isAbsolute;\r\n    }\r\n\r\n    if (resolvedDevice && resolvedAbsolute) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  // Convert slashes to backslashes when `resolvedDevice` points to an UNC\r\n  // root. Also squash multiple slashes into a single one where appropriate.\r\n  if (isUnc) {\r\n    resolvedDevice = normalizeUNCRoot(resolvedDevice);\r\n  }\r\n\r\n  // At this point the path should be resolved to a full absolute path,\r\n  // but handle relative paths to be safe (might happen when process.cwd()\r\n  // fails)\r\n\r\n  // Normalize the tail path\r\n  resolvedTail = normalizeArray(resolvedTail.split(/[\\\\\\/]+/),\r\n                                !resolvedAbsolute).join('\\\\');\r\n\r\n  return (resolvedDevice + (resolvedAbsolute ? '\\\\' : '') + resolvedTail) ||\r\n         '.';\r\n};\r\n\r\n\r\nwin32.normalize = function(path) {\r\n  var result = win32StatPath(path),\r\n      device = result.device,\r\n      isUnc = result.isUnc,\r\n      isAbsolute = result.isAbsolute,\r\n      tail = result.tail,\r\n      trailingSlash = /[\\\\\\/]$/.test(tail);\r\n\r\n  // Normalize the tail path\r\n  tail = normalizeArray(tail.split(/[\\\\\\/]+/), !isAbsolute).join('\\\\');\r\n\r\n  if (!tail && !isAbsolute) {\r\n    tail = '.';\r\n  }\r\n  if (tail && trailingSlash) {\r\n    tail += '\\\\';\r\n  }\r\n\r\n  // Convert slashes to backslashes when `device` points to an UNC root.\r\n  // Also squash multiple slashes into a single one where appropriate.\r\n  if (isUnc) {\r\n    device = normalizeUNCRoot(device);\r\n  }\r\n\r\n  return device + (isAbsolute ? '\\\\' : '') + tail;\r\n};\r\n\r\n\r\nwin32.isAbsolute = function(path) {\r\n  return win32StatPath(path).isAbsolute;\r\n};\r\n\r\nwin32.join = function() {\r\n  var paths = [];\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    var arg = arguments[i];\r\n    if (!util.isString(arg)) {\r\n      throw new TypeError('Arguments to path.join must be strings');\r\n    }\r\n    if (arg) {\r\n      paths.push(arg);\r\n    }\r\n  }\r\n\r\n  var joined = paths.join('\\\\');\r\n\r\n  // Make sure that the joined path doesn't start with two slashes, because\r\n  // normalize() will mistake it for an UNC path then.\r\n  //\r\n  // This step is skipped when it is very clear that the user actually\r\n  // intended to point at an UNC path. This is assumed when the first\r\n  // non-empty string arguments starts with exactly two slashes followed by\r\n  // at least one more non-slash character.\r\n  //\r\n  // Note that for normalize() to treat a path as an UNC path it needs to\r\n  // have at least 2 components, so we don't filter for that here.\r\n  // This means that the user can use join to construct UNC paths from\r\n  // a server name and a share name; for example:\r\n  //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\')\r\n  if (!/^[\\\\\\/]{2}[^\\\\\\/]/.test(paths[0])) {\r\n    joined = joined.replace(/^[\\\\\\/]{2,}/, '\\\\');\r\n  }\r\n\r\n  return win32.normalize(joined);\r\n};\r\n\r\n\r\n// path.relative(from, to)\r\n// it will solve the relative path from 'from' to 'to', for instance:\r\n// from = 'C:\\\\orandea\\\\test\\\\aaa'\r\n// to = 'C:\\\\orandea\\\\impl\\\\bbb'\r\n// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\r\nwin32.relative = function(from, to) {\r\n  from = win32.resolve(from);\r\n  to = win32.resolve(to);\r\n\r\n  // windows is not case sensitive\r\n  var lowerFrom = from.toLowerCase();\r\n  var lowerTo = to.toLowerCase();\r\n\r\n  var toParts = trimArray(to.split('\\\\'));\r\n\r\n  var lowerFromParts = trimArray(lowerFrom.split('\\\\'));\r\n  var lowerToParts = trimArray(lowerTo.split('\\\\'));\r\n\r\n  var length = Math.min(lowerFromParts.length, lowerToParts.length);\r\n  var samePartsLength = length;\r\n  for (var i = 0; i < length; i++) {\r\n    if (lowerFromParts[i] !== lowerToParts[i]) {\r\n      samePartsLength = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (samePartsLength == 0) {\r\n    return to;\r\n  }\r\n\r\n  var outputParts = [];\r\n  for (var i = samePartsLength; i < lowerFromParts.length; i++) {\r\n    outputParts.push('..');\r\n  }\r\n\r\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n\r\n  return outputParts.join('\\\\');\r\n};\r\n\r\n\r\nwin32._makeLong = function(path) {\r\n  // Note: this will *probably* throw somewhere.\r\n  if (!util.isString(path))\r\n    return path;\r\n\r\n  if (!path) {\r\n    return '';\r\n  }\r\n\r\n  var resolvedPath = win32.resolve(path);\r\n\r\n  if (/^[a-zA-Z]\\:\\\\/.test(resolvedPath)) {\r\n    // path is local filesystem path, which needs to be converted\r\n    // to long UNC path.\r\n    return '\\\\\\\\?\\\\' + resolvedPath;\r\n  } else if (/^\\\\\\\\[^?.]/.test(resolvedPath)) {\r\n    // path is network UNC path, which needs to be converted\r\n    // to long UNC path.\r\n    return '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.substring(2);\r\n  }\r\n\r\n  return path;\r\n};\r\n\r\n\r\nwin32.dirname = function(path) {\r\n  var result = win32SplitPath(path),\r\n      root = result[0],\r\n      dir = result[1];\r\n\r\n  if (!root && !dir) {\r\n    // No dirname whatsoever\r\n    return '.';\r\n  }\r\n\r\n  if (dir) {\r\n    // It has a dirname, strip trailing slash\r\n    dir = dir.substr(0, dir.length - 1);\r\n  }\r\n\r\n  return root + dir;\r\n};\r\n\r\n\r\nwin32.basename = function(path, ext) {\r\n  var f = win32SplitPath(path)[2];\r\n  // TODO: make this comparison case-insensitive on windows?\r\n  if (ext && f.substr(-1 * ext.length) === ext) {\r\n    f = f.substr(0, f.length - ext.length);\r\n  }\r\n  return f;\r\n};\r\n\r\n\r\nwin32.extname = function(path) {\r\n  return win32SplitPath(path)[3];\r\n};\r\n\r\n\r\nwin32.format = function(pathObject) {\r\n  if (!util.isObject(pathObject)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathObject' must be an object, not \" + typeof pathObject\r\n    );\r\n  }\r\n\r\n  var root = pathObject.root || '';\r\n\r\n  if (!util.isString(root)) {\r\n    throw new TypeError(\r\n        \"'pathObject.root' must be a string or undefined, not \" +\r\n        typeof pathObject.root\r\n    );\r\n  }\r\n\r\n  var dir = pathObject.dir;\r\n  var base = pathObject.base || '';\r\n  if (!dir) {\r\n    return base;\r\n  }\r\n  if (dir[dir.length - 1] === win32.sep) {\r\n    return dir + base;\r\n  }\r\n  return dir + win32.sep + base;\r\n};\r\n\r\n\r\nwin32.parse = function(pathString) {\r\n  if (!util.isString(pathString)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathString' must be a string, not \" + typeof pathString\r\n    );\r\n  }\r\n  var allParts = win32SplitPath(pathString);\r\n  if (!allParts || allParts.length !== 4) {\r\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\r\n  }\r\n  return {\r\n    root: allParts[0],\r\n    dir: allParts[0] + allParts[1].slice(0, -1),\r\n    base: allParts[2],\r\n    ext: allParts[3],\r\n    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\r\n  };\r\n};\r\n\r\n\r\nwin32.sep = '\\\\';\r\nwin32.delimiter = ';';\r\n\r\n\r\n// Split a filename into [root, dir, basename, ext], unix version\r\n// 'root' is just a slash, or nothing.\r\nvar splitPathRe =\r\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\r\nvar posix = {};\r\n\r\n\r\nfunction posixSplitPath(filename) {\r\n  return splitPathRe.exec(filename).slice(1);\r\n}\r\n\r\n\r\n// path.resolve([from ...], to)\r\n// posix version\r\nposix.resolve = function() {\r\n  var resolvedPath = '',\r\n      resolvedAbsolute = false;\r\n\r\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\r\n    var path = (i >= 0) ? arguments[i] : process.cwd();\r\n\r\n    // Skip empty and invalid entries\r\n    if (!util.isString(path)) {\r\n      throw new TypeError('Arguments to path.resolve must be strings');\r\n    } else if (!path) {\r\n      continue;\r\n    }\r\n\r\n    resolvedPath = path + '/' + resolvedPath;\r\n    resolvedAbsolute = path[0] === '/';\r\n  }\r\n\r\n  // At this point the path should be resolved to a full absolute path, but\r\n  // handle relative paths to be safe (might happen when process.cwd() fails)\r\n\r\n  // Normalize the path\r\n  resolvedPath = normalizeArray(resolvedPath.split('/'),\r\n                                !resolvedAbsolute).join('/');\r\n\r\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\r\n};\r\n\r\n// path.normalize(path)\r\n// posix version\r\nposix.normalize = function(path) {\r\n  var isAbsolute = posix.isAbsolute(path),\r\n      trailingSlash = path && path[path.length - 1] === '/';\r\n\r\n  // Normalize the path\r\n  path = normalizeArray(path.split('/'), !isAbsolute).join('/');\r\n\r\n  if (!path && !isAbsolute) {\r\n    path = '.';\r\n  }\r\n  if (path && trailingSlash) {\r\n    path += '/';\r\n  }\r\n\r\n  return (isAbsolute ? '/' : '') + path;\r\n};\r\n\r\n// posix version\r\nposix.isAbsolute = function(path) {\r\n  return path.charAt(0) === '/';\r\n};\r\n\r\n// posix version\r\nposix.join = function() {\r\n  var path = '';\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    var segment = arguments[i];\r\n    if (!util.isString(segment)) {\r\n      throw new TypeError('Arguments to path.join must be strings');\r\n    }\r\n    if (segment) {\r\n      if (!path) {\r\n        path += segment;\r\n      } else {\r\n        path += '/' + segment;\r\n      }\r\n    }\r\n  }\r\n  return posix.normalize(path);\r\n};\r\n\r\n\r\n// path.relative(from, to)\r\n// posix version\r\nposix.relative = function(from, to) {\r\n  from = posix.resolve(from).substr(1);\r\n  to = posix.resolve(to).substr(1);\r\n\r\n  var fromParts = trimArray(from.split('/'));\r\n  var toParts = trimArray(to.split('/'));\r\n\r\n  var length = Math.min(fromParts.length, toParts.length);\r\n  var samePartsLength = length;\r\n  for (var i = 0; i < length; i++) {\r\n    if (fromParts[i] !== toParts[i]) {\r\n      samePartsLength = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  var outputParts = [];\r\n  for (var i = samePartsLength; i < fromParts.length; i++) {\r\n    outputParts.push('..');\r\n  }\r\n\r\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n\r\n  return outputParts.join('/');\r\n};\r\n\r\n\r\nposix._makeLong = function(path) {\r\n  return path;\r\n};\r\n\r\n\r\nposix.dirname = function(path) {\r\n  var result = posixSplitPath(path),\r\n      root = result[0],\r\n      dir = result[1];\r\n\r\n  if (!root && !dir) {\r\n    // No dirname whatsoever\r\n    return '.';\r\n  }\r\n\r\n  if (dir) {\r\n    // It has a dirname, strip trailing slash\r\n    dir = dir.substr(0, dir.length - 1);\r\n  }\r\n\r\n  return root + dir;\r\n};\r\n\r\n\r\nposix.basename = function(path, ext) {\r\n  var f = posixSplitPath(path)[2];\r\n  // TODO: make this comparison case-insensitive on windows?\r\n  if (ext && f.substr(-1 * ext.length) === ext) {\r\n    f = f.substr(0, f.length - ext.length);\r\n  }\r\n  return f;\r\n};\r\n\r\n\r\nposix.extname = function(path) {\r\n  return posixSplitPath(path)[3];\r\n};\r\n\r\n\r\nposix.format = function(pathObject) {\r\n  if (!util.isObject(pathObject)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathObject' must be an object, not \" + typeof pathObject\r\n    );\r\n  }\r\n\r\n  var root = pathObject.root || '';\r\n\r\n  if (!util.isString(root)) {\r\n    throw new TypeError(\r\n        \"'pathObject.root' must be a string or undefined, not \" +\r\n        typeof pathObject.root\r\n    );\r\n  }\r\n\r\n  var dir = pathObject.dir ? pathObject.dir + posix.sep : '';\r\n  var base = pathObject.base || '';\r\n  return dir + base;\r\n};\r\n\r\n\r\nposix.parse = function(pathString) {\r\n  if (!util.isString(pathString)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathString' must be a string, not \" + typeof pathString\r\n    );\r\n  }\r\n  var allParts = posixSplitPath(pathString);\r\n  if (!allParts || allParts.length !== 4) {\r\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\r\n  }\r\n  allParts[1] = allParts[1] || '';\r\n  allParts[2] = allParts[2] || '';\r\n  allParts[3] = allParts[3] || '';\r\n\r\n  return {\r\n    root: allParts[0],\r\n    dir: allParts[0] + allParts[1].slice(0, -1),\r\n    base: allParts[2],\r\n    ext: allParts[3],\r\n    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\r\n  };\r\n};\r\n\r\n\r\nposix.sep = '/';\r\nposix.delimiter = ':';\r\n\r\n\r\nif (isWindows)\r\n  module.exports = win32;\r\nelse /* posix */\r\n  module.exports = posix;\r\n\r\nmodule.exports.posix = posix;\r\nmodule.exports.win32 = win32;\r\n"]},"metadata":{},"sourceType":"script"}